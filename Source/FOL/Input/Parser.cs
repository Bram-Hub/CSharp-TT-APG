// This code was generated by the Gardens Point Parser Generator
// Copyright (c) Wayne Kelly, QUT 2005-2010
// (see accompanying GPPGcopyright.rtf)

// GPPG version 1.4.6
// Machine:  DEADNOOB-PC
// DateTime: 5/1/2012 3:30:11 PM
// UserName: DeadNoob
// Input file <grammar.y - 5/1/2012 3:28:59 PM>

// options: no-lines gplex

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using QUT.Gppg;
using TruthTree2.FOL.Logic;

namespace TruthTree2.FOL.Input
{
    public enum Tokens
    {
        error = 1, EOF = 2, Identifier = 3, Variable = 4, And = 5, Or = 6,
        Not = 7, Iff = 8, If = 9, Forall = 10, Exists = 11, Equals = 12,
        LParen = 13, RParen = 14, False = 15
    };

    public struct ValueType
    {
        public string stringval;
        public WFF formulaval;
        public Term termval;
        public List<Term> terms;
        public List<WFF> wffs;
    }
    // Abstract base class for GPLEX scanners
    public abstract class ScanBase : AbstractScanner<ValueType, LexLocation>
    {
        private LexLocation __yylloc = new LexLocation();
        public override LexLocation yylloc { get { return __yylloc; } set { __yylloc = value; } }
        protected virtual bool yywrap() { return true; }
    }

    public class Parser : ShiftReduceParser<ValueType, LexLocation>
    {
#pragma warning disable 649
        private static Dictionary<int, string> aliasses;
#pragma warning restore 649
        private static Rule[] rules = new Rule[25];
        private static State[] states = new State[50];
        private static string[] nonTerms = new string[] {
      "formula", "atomicwff", "complexwff", "formulalist", "term", "termlist", 
      "line", "$accept", };

        static Parser()
        {
            states[0] = new State(new int[] { 15, 5, 13, 6, 3, 24, 1, 49, 2, -2 }, new int[] { -7, 1, -1, 3, -2, 4, -3, 25 });
            states[1] = new State(new int[] { 2, 2 });
            states[2] = new State(-1);
            states[3] = new State(-3);
            states[4] = new State(-10);
            states[5] = new State(-12);
            states[6] = new State(new int[] { 12, 7, 3, 18, 7, 21, 8, 26, 9, 30, 5, 34, 6, 38, 11, 41, 10, 45 });
            states[7] = new State(new int[] { 3, 11, 4, 12, 13, 13 }, new int[] { -5, 8 });
            states[8] = new State(new int[] { 3, 11, 4, 12, 13, 13 }, new int[] { -5, 9 });
            states[9] = new State(new int[] { 14, 10 });
            states[10] = new State(-13);
            states[11] = new State(-5);
            states[12] = new State(-6);
            states[13] = new State(new int[] { 3, 14 });
            states[14] = new State(-9, new int[] { -6, 15 });
            states[15] = new State(new int[] { 14, 16, 3, 11, 4, 12, 13, 13 }, new int[] { -5, 17 });
            states[16] = new State(-7);
            states[17] = new State(-8);
            states[18] = new State(-9, new int[] { -6, 19 });
            states[19] = new State(new int[] { 14, 20, 3, 11, 4, 12, 13, 13 }, new int[] { -5, 17 });
            states[20] = new State(-14);
            states[21] = new State(new int[] { 15, 5, 13, 6, 3, 24 }, new int[] { -1, 22, -2, 4, -3, 25 });
            states[22] = new State(new int[] { 14, 23 });
            states[23] = new State(-16);
            states[24] = new State(-15);
            states[25] = new State(-11);
            states[26] = new State(new int[] { 15, 5, 13, 6, 3, 24 }, new int[] { -1, 27, -2, 4, -3, 25 });
            states[27] = new State(new int[] { 15, 5, 13, 6, 3, 24 }, new int[] { -1, 28, -2, 4, -3, 25 });
            states[28] = new State(new int[] { 14, 29 });
            states[29] = new State(-17);
            states[30] = new State(new int[] { 15, 5, 13, 6, 3, 24 }, new int[] { -1, 31, -2, 4, -3, 25 });
            states[31] = new State(new int[] { 15, 5, 13, 6, 3, 24 }, new int[] { -1, 32, -2, 4, -3, 25 });
            states[32] = new State(new int[] { 14, 33 });
            states[33] = new State(-18);
            states[34] = new State(-24, new int[] { -4, 35 });
            states[35] = new State(new int[] { 14, 36, 15, 5, 13, 6, 3, 24 }, new int[] { -1, 37, -2, 4, -3, 25 });
            states[36] = new State(-19);
            states[37] = new State(-23);
            states[38] = new State(-24, new int[] { -4, 39 });
            states[39] = new State(new int[] { 14, 40, 15, 5, 13, 6, 3, 24 }, new int[] { -1, 37, -2, 4, -3, 25 });
            states[40] = new State(-20);
            states[41] = new State(new int[] { 4, 42 });
            states[42] = new State(new int[] { 15, 5, 13, 6, 3, 24 }, new int[] { -1, 43, -2, 4, -3, 25 });
            states[43] = new State(new int[] { 14, 44 });
            states[44] = new State(-21);
            states[45] = new State(new int[] { 4, 46 });
            states[46] = new State(new int[] { 15, 5, 13, 6, 3, 24 }, new int[] { -1, 47, -2, 4, -3, 25 });
            states[47] = new State(new int[] { 14, 48 });
            states[48] = new State(-22);
            states[49] = new State(-4);

            for (int sNo = 0; sNo < states.Length; sNo++) states[sNo].number = sNo;

            rules[1] = new Rule(-8, new int[] { -7, 2 });
            rules[2] = new Rule(-7, new int[] { });
            rules[3] = new Rule(-7, new int[] { -1 });
            rules[4] = new Rule(-7, new int[] { 1 });
            rules[5] = new Rule(-5, new int[] { 3 });
            rules[6] = new Rule(-5, new int[] { 4 });
            rules[7] = new Rule(-5, new int[] { 13, 3, -6, 14 });
            rules[8] = new Rule(-6, new int[] { -6, -5 });
            rules[9] = new Rule(-6, new int[] { });
            rules[10] = new Rule(-1, new int[] { -2 });
            rules[11] = new Rule(-1, new int[] { -3 });
            rules[12] = new Rule(-2, new int[] { 15 });
            rules[13] = new Rule(-2, new int[] { 13, 12, -5, -5, 14 });
            rules[14] = new Rule(-2, new int[] { 13, 3, -6, 14 });
            rules[15] = new Rule(-2, new int[] { 3 });
            rules[16] = new Rule(-3, new int[] { 13, 7, -1, 14 });
            rules[17] = new Rule(-3, new int[] { 13, 8, -1, -1, 14 });
            rules[18] = new Rule(-3, new int[] { 13, 9, -1, -1, 14 });
            rules[19] = new Rule(-3, new int[] { 13, 5, -4, 14 });
            rules[20] = new Rule(-3, new int[] { 13, 6, -4, 14 });
            rules[21] = new Rule(-3, new int[] { 13, 11, 4, -1, 14 });
            rules[22] = new Rule(-3, new int[] { 13, 10, 4, -1, 14 });
            rules[23] = new Rule(-4, new int[] { -4, -1 });
            rules[24] = new Rule(-4, new int[] { });
        }

        protected override void Initialize()
        {
            this.InitSpecialTokens((int)Tokens.error, (int)Tokens.EOF);
            this.InitStates(states);
            this.InitRules(rules);
            this.InitNonTerminals(nonTerms);
        }

        protected override void DoAction(int action)
        {
            switch (action)
            {
                case 2: // line -> /* empty */
                    { result = null; }
                    break;
                case 3: // line -> formula
                    { result = ValueStack[ValueStack.Depth - 1].formulaval; }
                    break;
                case 4: // line -> error
                    { result = null; }
                    break;
                case 5: // term -> Identifier
                    { CurrentSemanticValue.termval = new Constant(ValueStack[ValueStack.Depth - 1].stringval); }
                    break;
                case 6: // term -> Variable
                    { CurrentSemanticValue.termval = new Variable(ValueStack[ValueStack.Depth - 1].stringval); }
                    break;
                case 7: // term -> LParen, Identifier, termlist, RParen
                    { CurrentSemanticValue.termval = new Function(ValueStack[ValueStack.Depth - 3].stringval, ValueStack[ValueStack.Depth - 2].terms.ToArray()); }
                    break;
                case 8: // termlist -> termlist, term
                    { ValueStack[ValueStack.Depth - 2].terms.Add(ValueStack[ValueStack.Depth - 1].termval); CurrentSemanticValue.terms = ValueStack[ValueStack.Depth - 2].terms; }
                    break;
                case 9: // termlist -> /* empty */
                    { CurrentSemanticValue.terms = new List<Term>(); }
                    break;
                case 10: // formula -> atomicwff
                    { CurrentSemanticValue.formulaval = ValueStack[ValueStack.Depth - 1].formulaval; }
                    break;
                case 11: // formula -> complexwff
                    { CurrentSemanticValue.formulaval = ValueStack[ValueStack.Depth - 1].formulaval; }
                    break;
                case 12: // atomicwff -> False
                    { CurrentSemanticValue.formulaval = new Contradiction(); }
                    break;
                case 13: // atomicwff -> LParen, Equals, term, term, RParen
                    { CurrentSemanticValue.formulaval = new Identity(ValueStack[ValueStack.Depth - 3].termval, ValueStack[ValueStack.Depth - 2].termval); }
                    break;
                case 14: // atomicwff -> LParen, Identifier, termlist, RParen
                    { CurrentSemanticValue.formulaval = new Predicate(ValueStack[ValueStack.Depth - 3].stringval, ValueStack[ValueStack.Depth - 2].terms.ToArray()); }
                    break;
                case 15: // atomicwff -> Identifier
                    { CurrentSemanticValue.formulaval = new Predicate(ValueStack[ValueStack.Depth - 1].stringval); }
                    break;
                case 16: // complexwff -> LParen, Not, formula, RParen
                    { CurrentSemanticValue.formulaval = ValueStack[ValueStack.Depth - 2].formulaval.GetNegation(); }
                    break;
                case 17: // complexwff -> LParen, Iff, formula, formula, RParen
                    { CurrentSemanticValue.formulaval = new Biconditional(ValueStack[ValueStack.Depth - 3].formulaval, ValueStack[ValueStack.Depth - 2].formulaval); }
                    break;
                case 18: // complexwff -> LParen, If, formula, formula, RParen
                    { CurrentSemanticValue.formulaval = new Conditional(ValueStack[ValueStack.Depth - 3].formulaval, ValueStack[ValueStack.Depth - 2].formulaval); }
                    break;
                case 19: // complexwff -> LParen, And, formulalist, RParen
                    { CurrentSemanticValue.formulaval = new Conjunction(ValueStack[ValueStack.Depth - 2].wffs.ToArray()); }
                    break;
                case 20: // complexwff -> LParen, Or, formulalist, RParen
                    { CurrentSemanticValue.formulaval = new Disjunction(ValueStack[ValueStack.Depth - 2].wffs.ToArray()); }
                    break;
                case 21: // complexwff -> LParen, Exists, Variable, formula, RParen
                    { CurrentSemanticValue.formulaval = new Existential(new Variable(ValueStack[ValueStack.Depth - 3].stringval), ValueStack[ValueStack.Depth - 2].formulaval); }
                    break;
                case 22: // complexwff -> LParen, Forall, Variable, formula, RParen
                    { CurrentSemanticValue.formulaval = new Universal(new Variable(ValueStack[ValueStack.Depth - 3].stringval), ValueStack[ValueStack.Depth - 2].formulaval); }
                    break;
                case 23: // formulalist -> formulalist, formula
                    { ValueStack[ValueStack.Depth - 2].wffs.Add(ValueStack[ValueStack.Depth - 1].formulaval); CurrentSemanticValue.wffs = ValueStack[ValueStack.Depth - 2].wffs; }
                    break;
                case 24: // formulalist -> /* empty */
                    { CurrentSemanticValue.wffs = new List<WFF>(); }
                    break;
            }
        }

        protected override string TerminalToString(int terminal)
        {
            if (aliasses != null && aliasses.ContainsKey(terminal))
                return aliasses[terminal];
            else if (((Tokens)terminal).ToString() != terminal.ToString(CultureInfo.InvariantCulture))
                return ((Tokens)terminal).ToString();
            else
                return CharToString((char)terminal);
        }


        Parser() : base(null) { }

        private WFF result;

        public static WFF parseString(string str)
        {
            Scanner scanner = new Scanner();
            scanner.SetSource(str, 0);

            Parser parser = new Parser();
            parser.Scanner = scanner;

            parser.Parse();

            return parser.result;
        }
    }
}
